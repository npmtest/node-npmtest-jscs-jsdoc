{"/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/test.js":"/* istanbul instrument in package npmtest_jscs_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/lib.npmtest_jscs_jsdoc.js":"/* istanbul instrument in package npmtest_jscs_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jscs_jsdoc = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jscs_jsdoc = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jscs-jsdoc && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jscs_jsdoc */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jscs_jsdoc\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jscs_jsdoc.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jscs_jsdoc.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jscs_jsdoc.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jscs_jsdoc.__dirname + '/lib.npmtest_jscs_jsdoc.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/index.js":"/**\n * @param {module:jscs/lib/Configuration} configuration\n */\nmodule.exports = function(configuration) {\n    delete configuration._rules.jsDoc;\n    configuration.registerRule(require('./rules/validate-jsdoc'));\n};\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/esprima-helpers.js":"module.exports = {\n    closestScopeNode: closestScopeNode\n};\n\nvar scopeNodeTypes = [\n    'Program',\n    'FunctionDeclaration',\n    'FunctionExpression',\n    'ArrowFunctionExpression'\n];\n\n/**\n * Search for the closest scope node tree for Node\n *\n * @param {{type: string}} n\n * @returns {EsprimaNode}\n */\nfunction closestScopeNode(n) {\n    while (n && scopeNodeTypes.indexOf(n.type) === -1) {\n        n = n.parentElement;\n    }\n    return n;\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/jsdoc.js":"var assert = require('assert');\nvar commentParser = require('comment-parser');\n\nvar TypeParser = require('jsdoctypeparser').Parser;\nvar TypeBuilder = require('jsdoctypeparser').Builder;\n\nvar getNodeColumn = require('./utils').getNodeColumn;\nvar getLineInfo = require('./utils').getLineInfo;\n\n// wtf but it needed to stop writing warnings to stdout\n// and revert exceptions functionality\nTypeBuilder.ENABLE_EXCEPTIONS = true;\n\n// jscs:disable requireCamelCaseOrUpperCaseIdentifiers\nvar PARSERS = {\n    tag: commentParser.PARSERS.parse_tag,\n    type: commentParser.PARSERS.parse_type,\n    description: commentParser.PARSERS.parse_description,\n};\n// jscs:enable\nvar RE_SPACE = /\\s/;\n\nmodule.exports = {\n\n    /**\n     * @param {string} commentNode\n     * @returns {DocComment}\n     */\n    createDocCommentByCommentNode: function(commentNode) {\n        var column = getNodeColumn(commentNode);\n        var lines = [(new Array(column + 1)).join(' '), '/*', commentNode.value, '*/']\n            .join('').split('\\n').map(function(v) {\n                return v.substr(column);\n            });\n        var value = lines.join('\\n');\n        return new DocComment(value, commentNode, commentNode.getSourceCode(), column);\n    },\n\n    doc: DocComment,\n    tag: DocTag,\n    type: DocType,\n    location: DocLocation\n};\n\n/**\n * jsdoc comment object\n *\n * @param {string} value\n * @param {Element} node\n * @param {string} originalValue\n * @param {number} column\n * @constructor\n */\nfunction DocComment(value, node, originalValue, column) {\n    originalValue = originalValue || value;\n    column = column || 0;\n\n    this.node = node;\n\n    // parse comments\n    var _parsed = _parseComment(value) || {};\n\n    // fill up fields\n    this.value = value;\n    this.lines = value.split('\\n');\n    this.valid = _parsed.hasOwnProperty('line');\n\n    // doc parsed data\n    var _d = _parsed.source;\n    var _dog = _d && _d.indexOf('\\n@');\n    this.description = !_d || _d[0] === '@' ?\n        null\n        : (_dog === -1 ? _d : _d.substr(0, _dog));\n\n    var lineInfo = getLineInfo(originalValue);\n    this.tags = (_parsed.tags || []).map(function(tag) {\n        return new DocTag(\n            tag,\n            new DocLocation(lineInfo[tag.line].offset + 3 + column)\n        );\n    });\n\n    // calculate abstract flag\n    this.abstract = this.tags.some(function(v) {\n        return v.id === 'abstract' || v.id === 'virtual';\n    });\n\n    /**\n     * @param {function(this: DocComment, DocTag): DocComment} fn\n     * @returns {DocComment}\n     */\n    this.iterate = function forEachTag(fn) {\n        this.tags.forEach(fn, this);\n        return this;\n    };\n\n    /**\n     * @param {string|Array.<string>} types\n     * @param {function(this: DocComment, DocTag): DocComment} fn\n     * @returns {DocComment}\n     */\n    this.iterateByType = function iterateByTypes(types, fn) {\n        var k = 0;\n        types = Array.isArray(types) ? types : [types];\n        this.tags.forEach(function(tag) {\n            if (types.indexOf(tag.id) === -1) {\n                return;\n            }\n            fn.call(this, tag, k++);\n        }, this);\n        return this;\n    };\n}\n\n/**\n * Simple jsdoc tag object\n *\n * @param {Object} tag object from comment parser, fields: tag, line, value, name, type, description\n * @param {DocLocation} loc\n * @constructor\n */\nfunction DocTag(tag, loc) {\n    this.id = tag.tag;\n    this.line = tag.line;\n    this.value = tag.value;\n    this.name = undefined;\n    this.type = undefined;\n\n    this.description = tag.description;\n    this.optional = tag.optional;\n    this.default = tag.default;\n\n    this.loc = loc;\n\n    if (tag.name) {\n        this.name = {\n            loc: this.loc.shift(tag.value.indexOf(tag.name)),\n            value: tag.name\n        };\n    }\n\n    if (tag.type) {\n        this.type = new DocType(tag.type, this.loc.shift(tag.value.indexOf(tag.type)));\n    }\n}\n\n/**\n * Parses jsdoctype string and provides several methods to work with it\n *\n * @param {string} type\n * @param {DocLocation} loc\n * @constructor\n */\nfunction DocType(type, loc) {\n    assert(type, 'type can\\'t be empty');\n    assert(loc, 'location should be passed');\n\n    this.value = type;\n    this.loc = loc;\n\n    var parsed = _parseDocType(type);\n    var data = parsed.valid ? _simplifyType(parsed) : [];\n\n    this.optional = parsed.optional;\n    this.variable = parsed.variable;\n    this.valid = parsed.valid;\n\n    if (parsed.valid && parsed.variable) {\n        this.loc.offset = this.loc.offset + 3; // ' * '.length\n    }\n\n    /**\n     * Match type\n     *\n     * @param {EsprimaNode} node\n     * @returns {boolean}\n     */\n    this.match = function(node) {\n        return jsDocMatchType(data, node);\n    };\n\n    /**\n     * @param {function(TypeBuilder)} cb Calling for each node\n     * @returns {Array}\n     */\n    this.iterate = function(cb) {\n        if (!parsed.valid) {\n            return [];\n        }\n        return _iterateDocTypes(parsed, cb);\n    };\n}\n\n/**\n * DocLocation\n *\n * @constructor\n * @param {number} offset\n * @param {(Object|DocLocation)} [rel]\n */\nfunction DocLocation(offset, rel) {\n    assert(Number.isFinite(offset) && offset >= 0, 'offset should be greater than zero');\n    rel = rel || {};\n    this.offset = Number(offset) + Number(rel.offset || 0);\n}\n\n/**\n * Shift location by line and column\n *\n * @param {number|Object} offset\n * @returns {DocLocation}\n */\nDocLocation.prototype.shift = function(offset) {\n    if (typeof offset === 'object') {\n        offset = offset.offset;\n    }\n    return new DocLocation(offset, this);\n};\n\n/**\n * Comment parsing helper\n *\n * @param {string} comment\n * @returns {Object}\n * @private\n */\nfunction _parseComment(comment) {\n    return commentParser(comment, {\n        parsers: [\n            // parse tag\n            function(str) {\n                var res = PARSERS.tag.call(this, str);\n                res.data.value = str;\n                return res;\n            },\n            PARSERS.type,\n            _parseName,\n            PARSERS.description,\n        ]\n    })[0];\n}\n\n/**\n * analogue of str.match(/@(\\S+)(?:\\s+\\{([^\\}]+)\\})?(?:\\s+(\\S+))?(?:\\s+([^$]+))?/);\n *\n * @param {string} str raw jsdoc string\n * @returns {?Object} parsed tag node\n */\nfunction _parseName(str, data) {\n    if (data.errors && data.errors.length) {\n        return null;\n    }\n\n    var l        = str.length;\n    var pos      = _skipws(str);\n    var ch       = '';\n    var name     = '';\n    var brackets = 0;\n    var chevrons = 0;\n    var ticks    = 0;\n\n    while (pos < l) {\n        ch = str[pos];\n        brackets += ch === '[' ? 1 : ch === ']' ? -1 : 0;\n        chevrons += ch === '<' ? 1 : ch === '>' ? -1 : 0;\n        if (ch === '`') {\n            ticks++;\n        }\n        if (ticks % 2 === 0 && chevrons === 0 && brackets === 0 && RE_SPACE.test(ch)) {\n            break;\n        }\n        name += ch;\n        pos ++;\n    }\n\n    if (brackets !== 0) { throw Error('Invalid `name`, unpaired brackets'); }\n    if (chevrons !== 0) { throw Error('Invalid `name`, unpaired chevrons'); }\n    if (ticks % 2 !== 0) { throw Error('Invalid `name`, unpaired ticks'); }\n\n    var res = {\n        name: name,\n        default: undefined,\n        optional: false,\n        required: false,\n        ticked: false\n    };\n\n    // strip ticks (support for ticked variables)\n    if (name[0] === '`' && name[name.length - 1] === '`') {\n        res.ticked = true;\n        name = name.slice(1, -1).trim();\n    }\n\n    // strip chevrons\n    if (name[0] === '<' && name[name.length - 1] === '>') {\n        res.required = true;\n        name = name.slice(1, -1).trim();\n    }\n\n    // strip brackets\n    if (name[0] === '[' && name[name.length - 1] === ']') {\n        res.optional = true;\n        name = name.slice(1, -1).trim();\n\n        var eqPos = name.indexOf('=');\n        if (eqPos !== -1) {\n            res.default = name.substr(eqPos + 1).trim().replace(/^([\"'])(.+)(\\1)$/, '$2');\n            name = name.substr(0, eqPos).trim();\n        }\n    }\n\n    res.name = name;\n\n    return {\n        source: str.substr(0, pos),\n        data: res\n    };\n\n    /**\n     * Returns the next to whitespace char position in a string\n     *\n     * @param {string} str\n     * @return {number}\n     */\n    function _skipws(str) {\n        var i = 0;\n        var l = str.length;\n        var ch;\n        do {\n            ch = str[i];\n            if (ch !== ' ' && ch !== '\\t') {\n                break;\n            }\n        } while (++i < l);\n        return i;\n    }\n}\n\n/**\n * @param {string} typeString\n * @returns {?Array.<SimplifiedType>} - parsed jsdoctype string as array\n */\nfunction _parseDocType(typeString) {\n    var parser = new TypeParser();\n    var node;\n    try {\n        node = parser.parse(typeString);\n        node.valid = true;\n    } catch (e) {\n        node = {};\n        node.error = e.message;\n        node.valid = false;\n    }\n    return node;\n}\n\n/**\n * @param {EsprimaNode} node\n * @param {Function} cb\n * @returns {Array}\n */\nfunction _iterateDocTypes(node, cb) {\n    var res;\n\n    switch (true) {\n        case node instanceof TypeBuilder.TypeUnion:\n            // optional: boolean,\n            // nullable: boolean,\n            // variable: boolean,\n            // nonNullable: boolean,\n            // all: boolean,\n            // unknown: boolean,\n            // types: Array.<TypeName|GenericType|FunctionType|RecordType>\n            res = node.types.map(function(subnode) {\n                if (node.collectionNode) {\n                    subnode.parentElement = node.collectionNode;\n                }\n                return _iterateDocTypes(subnode, cb);\n            }) || [];\n            if (node.nullable) {\n                var subnode = {typeName: 'null', collectionNode: node};\n                res.concat(cb(subnode));\n            }\n            break;\n\n        case node instanceof TypeBuilder.TypeName:\n            // name: string\n            node.typeName = node.name;\n            res = cb(node);\n            break;\n\n        case node instanceof TypeBuilder.GenericType:\n            // genericTypeName: string,\n            // parameterTypeUnions: Array.<TypeUnion>\n            node.typeName = node.genericTypeName.type;\n            res = cb(node) || [];\n            if (node.parameterTypeUnions) {\n                // node.parameterTypeUnions.collectionNode = node;\n                res.concat(node.parameterTypeUnions.map(function(subnode) {\n                    subnode.parentElement = node;\n                    _iterateDocTypes(subnode, cb);\n                }));\n            }\n            break;\n\n        case node instanceof TypeBuilder.FunctionType:\n            // parameterTypeUnions: Array.<TypeUnion>,\n            // returnTypeUnion: TypeUnion|null,\n            // isConstructor: boolean,\n            // contextTypeUnion: TypeUnion|null\n            node.typeName = 'Function';\n            res = cb(node) || [];\n            res.concat(node.parameterTypeUnions.map(function(subnode) {\n                subnode.parentElement = node;\n                _iterateDocTypes(subnode, cb);\n            }));\n            if (node.returnTypeUnion) {\n                node.returnTypeUnion.collectionNode = node;\n                res.concat(_iterateDocTypes(node.returnTypeUnion, cb));\n            }\n            if (node.contextTypeUnion) {\n                node.contextTypeUnion.collectionNode = node;\n                res.concat(_iterateDocTypes(node.contextTypeUnion, cb));\n            }\n            break;\n\n        case node instanceof TypeBuilder.RecordType:\n            // entries: Array.<RecordEntry>\n            node.typeName = 'Object';\n            res = cb(node) || [];\n            if (node.entries) {\n                res.concat(node.entries.map(function(subnode) {\n                    subnode.parentElement = node;\n                    _iterateDocTypes(subnode, cb);\n                }));\n            }\n            break;\n\n        case node instanceof TypeBuilder.RecordType.Entry:\n            // name: string,\n            // typeUnion: TypeUnion\n            node.typeUnion.collectionNode = node;\n            res = _iterateDocTypes(node.typeUnion, cb);\n            break;\n\n        case node instanceof TypeBuilder.ModuleName:\n            node.typeName = node.name;\n            node.module = true;\n            res = cb(node);\n            break;\n\n        default:\n            throw new Error('DocType: Unsupported doc node');\n    }\n\n    return res;\n}\n\n/**\n * Converts AST jsDoc node to simple object\n *\n * @param {Object} node\n * @returns {!Array.<SimplifiedType>}\n * @see https://github.com/Kuniwak/jsdoctypeparser\n */\nfunction _simplifyType(node) {\n    var res = [];\n    _iterateDocTypes(node, function(type) {\n        if (!type.parentElement && (!type.collectionNode || !type.collectionNode.parentElement)) {\n            res.push({type: type.typeName});\n        }\n    });\n    return res;\n}\n\nvar jsPrimitives = 'string number boolean null undefined Object Function Array Date RegExp'\n    .toLowerCase().split(' ');\n\n/**\n * Compare parsed jsDocTypes with esprima node\n *\n * @param {SimplifiedType[]} variants - result of jsDocParseType\n * @param {Object} argument - esprima source code node\n */\nfunction jsDocMatchType(variants, argument) {\n    var i;\n    var l;\n    var variant;\n    var type;\n    var primitive;\n    var result = null;\n\n    for (i = 0, l = variants.length; i < l; i += 1) {\n        variant = variants[i][0] || variants[i];\n        if (variant.unknown || !variant.type) {\n            result = true;\n            break;\n        }\n\n        type = variant.type.toLowerCase();\n        primitive = jsPrimitives.indexOf(type) !== -1;\n\n        if (argument.type === 'NullLiteral') {\n            result = result || (type === 'null');\n        } else if (argument.type === 'RegExpLiteral') {\n            result = result || (type === 'regexp');\n\n        } else if (argument.type === 'StringLiteral') {\n            result = result || (type === 'string');\n\n        } else if (argument.type === 'BooleanLiteral') {\n            result = result || (type === 'boolean');\n\n        } else if (argument.type === 'NumericLiteral') {\n            result = result || (type === 'number');\n\n        } else if (argument.type === 'ObjectExpression') {\n            result = result || (type === 'object');\n            result = result || (!primitive);\n\n        } else if (argument.type === 'ArrayExpression') {\n            result = result || (type === 'array');\n\n        } else if (argument.type === 'NewExpression' && type === 'object') {\n            result = true;\n\n        } else if (argument.type === 'NewExpression') {\n            var c = argument.callee;\n            var exam = c.name;\n            if (!exam && c.type === 'MemberExpression') {\n                if (c.object.type === 'ThisExpression') {\n                    result = true;\n                    break;\n                }\n                var cur = c;\n                exam = [];\n                while (cur.object) {\n                    exam.unshift(cur.property.name);\n                    cur = cur.object;\n                }\n                exam.unshift(cur.name);\n                exam = exam.join('.');\n            }\n            exam = exam.toLowerCase();\n            result = result || (type === exam);\n        }\n\n        if (result) {\n            break;\n        }\n    }\n\n    // variables, expressions, another behavior\n    return result !== false;\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/utils.js":"var lineBreakRegexGlobal = /\\r\\n|\\r|\\n/g;\n\n/**\n * @param {Element} node\n * @returns {number}\n */\nexports.getNodeColumn = function(node) {\n    var currentToken = node.getFirstToken().getPreviousToken();\n    var indentationLevel = 0;\n    while (currentToken) {\n        if (currentToken.getNewlineCount() > 0) {\n            var sourceCodeLines = currentToken.getSourceCodeLines();\n            indentationLevel += sourceCodeLines[sourceCodeLines.length - 1].length;\n            break;\n        }\n\n        indentationLevel += currentToken.getSourceCodeLength();\n\n        currentToken = currentToken.getPreviousToken();\n    }\n    return indentationLevel;\n};\n\n/**\n * @param {string} code\n * @returns {Array}\n */\nexports.getLineInfo = function(code) {\n    var lines = [];\n    lineBreakRegexGlobal.lastIndex = 0;\n    var lastOffset = 0;\n    var match;\n    while ((match = lineBreakRegexGlobal.exec(code)) !== null) {\n        lines.push({\n            offset: lastOffset,\n            text: code.substring(lastOffset, match.index),\n            lineBreak: match[0]\n        });\n        lastOffset = match.index + match[0].length;\n    }\n    lines.push({offset: lastOffset, text: code.substr(lastOffset), lineBreak: null});\n    return lines;\n};\n\n/**\n * @param {Element} tokenBefore\n * @param {Element} tokenAfter\n * @returns {number}\n */\nexports.getLineCountBetween = function(tokenBefore, tokenAfter) {\n    if (tokenBefore === tokenAfter) {\n        return 0;\n    }\n\n    var currentToken = tokenBefore.getNextToken();\n    var lineCount = 0;\n    while (currentToken) {\n        if (currentToken === tokenAfter) {\n            break;\n        }\n\n        lineCount += currentToken.getNewlineCount();\n        currentToken = currentToken.getNextToken();\n    }\n    return lineCount;\n};\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc.js":"var assert = require('assert');\n\nvar jsdoc = require('../jsdoc');\nvar getLineCountBetween = require('../utils').getLineCountBetween;\nvar getNodeColumn = require('../utils').getNodeColumn;\nvar esprimaHelpers = require('../esprima-helpers');\nvar validators = require('./validate-jsdoc/index');\n\n/** @type {string[]} - list of function node types */\nvar functionNodeTypes = [\n    'FunctionDeclaration',\n    'FunctionExpression',\n    'ArrowFunctionExpression',\n];\n\n/** @type {string[]} - list of node types with jsdocs */\nvar jsdocableTypes = []\n    .concat(functionNodeTypes);\n\n/**\n * Rule constructor\n *\n * @this {module:jscs/Rule}\n * @constructor\n */\nmodule.exports = function() {};\n\nmodule.exports.prototype = {\n\n    /**\n     * Load all rules and init them\n     *\n     * @param {Object} options\n     * @throws {Error} If options is not an Object\n     */\n    configure: function(options) {\n        assert(typeof options === 'object', 'jsDoc option requires object value');\n\n        // rules structured by scopes-tags for jsdoc-tags\n        var rulesForTags = this._rulesForTags = {};\n        // rules structured by scopes for nodes\n        var rulesForNodes = this._rulesForNodes = {};\n\n        this._options = options;\n        this._optionsList = Object.keys(options);\n\n        // load validators\n        this._validators = validators.load(this._optionsList);\n        assert(this._validators.length, 'jsDoc plugin was not configured properly');\n\n        // registering validators\n        this._validators.forEach(function(v) {\n            // check options\n            if (v.options) {\n                validators.checkOptions(v, options);\n            }\n            // configure\n            if (v.configure) {\n                v.configure.call(this, options);\n            }\n            // index rules by tags and scopes\n            (v.scopes || ['']).forEach(function(scope) {\n                if (!v.tags) {\n                    assert(v.length === 2, 'jsDoc rules: Wrong arity in ' + v._name + ' validator');\n                    rulesForNodes[scope] = rulesForNodes[scope] || [];\n                    rulesForNodes[scope].push(v);\n                    return;\n                }\n                assert(v.length === 3, 'jsDoc rules: Wrong arity in ' + v._name + ' validator');\n                rulesForTags[scope] = rulesForTags[scope] || {};\n                v.tags.forEach(function(tag) {\n                    var dtag = '@' + tag;\n                    rulesForTags[scope][dtag] = rulesForTags[scope][dtag] || [];\n                    rulesForTags[scope][dtag].push(v);\n                });\n            });\n        }, this);\n    },\n\n    /**\n     * @returns {string}\n     */\n    getOptionName: function() {\n        return 'jsDoc';\n    },\n\n    /**\n     * @param {module:jscs/JsFile} file\n     * @param {module:jscs/Errors} errors\n     */\n    check: function(file, errors) {\n        patchNodesInFile(file);\n        this._iterate = file.iterate;\n\n        var _this = this;\n        var scopes = {\n            'function': functionNodeTypes,\n        };\n\n        // classic checker\n        if (_this._rulesForNodes.file) {\n            // call file checkers\n            var validators = _this._rulesForNodes.file;\n            if (validators) {\n                validators.forEach(function(v) {\n                    v.call(_this, file, errors);\n                });\n            }\n        }\n\n        // iterate over scopes\n        Object.keys(scopes).forEach(function(scope) {\n\n            // skip unused\n            if (!_this._rulesForNodes[scope] && !_this._rulesForTags[scope]) {\n                return;\n            }\n\n            // traverse ast tree and search scope node types\n            file.iterateNodesByType(scopes[scope], function(node) {\n                // init\n                var validators;\n\n                // call node checkers\n                validators = _this._rulesForNodes[scope];\n                if (validators) {\n                    validators.forEach(function(v) {\n                        v.call(_this, node, addError);\n                    });\n                }\n\n                validators = _this._rulesForTags[scope];\n                if (!validators || !node.jsdoc || !node.jsdoc.valid) {\n                    return;\n                }\n\n                // call rule checkers\n                node.jsdoc.iterate(function(tag) {\n                    if (!validators['@' + tag.id]) {\n                        return;\n                    }\n                    // call tag validator\n                    validators['@' + tag.id].forEach(function(v) {\n                        v.call(_this, node, tag, fixErrLocation(addError, tag));\n                    });\n                });\n\n                /**\n                 * Send error to jscs\n                 *\n                 * @param {string} text\n                 * @param {number|DocLocation} offset\n                 */\n                function addError(text, offset) {\n                    if (typeof offset === 'object') {\n                        if (offset.type) {\n                            errors.add(text, offset, 0);\n                            return;\n                        } else {\n                            offset = offset.offset;\n                        }\n                    }\n                    errors.add(text, node.jsdoc.node, offset);\n                }\n\n                /**\n                 * Generates function with location fixing logic to send error to jscs\n                 *\n                 * @param {function(string, number|Object)} err\n                 * @param {DocTag} tag\n                 * @returns {function(string, number|Object)}\n                 */\n                function fixErrLocation(err, tag) {\n                    return function(text, offset) {\n                        err(text, offset || tag.loc.offset);\n                    };\n                }\n            });\n\n        });\n    },\n\n    /**\n     * Caching scope search. todo: move to patchNodesInFile\n     *\n     * @param {Object} node\n     */\n    _getReturnStatementsForNode: function(node) {\n        if (node.jsdoc.returnStatements) {\n            return node.jsdoc.returnStatements;\n        }\n\n        var statements = [];\n        this._iterate(function(n) {\n            if (n && n.type === 'ReturnStatement' && n.argument) {\n                if (node === esprimaHelpers.closestScopeNode(n)) {\n                    statements.push(n.argument);\n                }\n            }\n        }, node);\n\n        node.jsdoc.returnStatements = statements;\n        return statements;\n    }\n};\n\n/**\n * Extends each node with helper properties\n *\n * @param {Object} file\n */\nfunction patchNodesInFile(file) {\n    if (file._jsdocs) {\n        return;\n    }\n\n    // jsdoc property for nodes\n    file.iterateNodesByType(jsdocableTypes, function(node) {\n        Object.defineProperty(node, 'jsdoc', {\n            get: getJsdoc\n        });\n    });\n\n    /**\n     * Fetchs jsdoc block for this\n     *\n     * @this {module:esprima/Node}\n     * @returns {DocComment}\n     */\n    function getJsdoc() {\n        if (this.hasOwnProperty('_jsdoc')) {\n            return this._jsdoc;\n        }\n\n        var node = functionNodeTypes.indexOf(this.type) !== -1 ?\n            findFirstNodeInLine(this) : this;\n        var res = findDocCommentBeforeNode(node, this);\n\n        this._jsdoc = res ? jsdoc.createDocCommentByCommentNode(res) : null;\n\n        return this._jsdoc;\n    }\n\n    /**\n     * Finds the first node on the same line as passed node\n     *\n     * @param {?module:esprima/Node} node\n     * @returns {?module:esprima/Node}\n     */\n    function findFirstNodeInLine(node) {\n        var parent = node.parentElement;\n        if (!parent || getLineCountBetween(parent.getFirstToken(), node.getFirstToken()) > 0) {\n            return node;\n        }\n        return findFirstNodeInLine(parent);\n    }\n\n    /**\n     * Finds DocComment in file before passed line number\n     *\n     * @param {?module:esprima/Node} node\n     * @returns {?module:esprima/Node}\n     */\n    function findDocCommentBeforeNode(node, self) {\n        var res = node.getFirstToken().getPreviousNonWhitespaceToken();\n        if (!res || res.type !== 'CommentBlock' || res.value.charAt(0) !== '*') {\n            return null;\n        }\n\n        // Indent should be the same\n        if (getNodeColumn(res) !== getNodeColumn(node)) {\n            return null;\n        }\n\n        // IIFE should be on the next line to be sticked\n        if ((self.type === 'FunctionExpression' || self.type === 'ArrowFunctionExpression') &&\n            self.parentElement.type === 'CallExpression' &&\n            getLineCountBetween(res, self.getFirstToken()) > 1\n        ) {\n            return null;\n        }\n\n        return res;\n    }\n\n    // mark object as patched\n    file._jsdocs = true;\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/index.js":"var assert = require('assert');\n\nvar validatorsByName = module.exports = {\n    checkTypes: require('./check-types'),\n\n    checkParamExistence: require('./check-param-existence'),\n    checkParamNames: require('./check-param-names'),\n    checkRedundantParams: require('./check-redundant-params'),\n    requireParamTypes: require('./require-param-types'),\n    requireParamDescription: require('./require-param-description'),\n    requireHyphenBeforeDescription: require('./require-hyphen-before-description'),\n\n    checkReturnTypes: require('./check-return-types'),\n    requireReturnTypes: require('./require-return-types'),\n    requireReturnDescription: require('./require-return-description'),\n    checkRedundantReturns: require('./check-redundant-returns'),\n\n    checkAnnotations: require('./check-annotations'),\n\n    requireNewlineAfterDescription: require('./require-newline-after-description'),\n    disallowNewlineAfterDescription: require('./disallow-newline-after-description'),\n\n    requireDescriptionCompleteSentence: require('./require-description-complete-sentence'),\n\n    checkRedundantAccess: require('./check-redundant-access'),\n    enforceExistence: require('./enforce-existence'),\n    leadingUnderscoreAccess: require('./leading-underscore-access')\n};\n\nObject.defineProperty(validatorsByName, 'load', {\n    /**\n     * loads and initializes existing and required validators\n     *\n     * @param {Object} passedOptions\n     * @returns {Array.<Function>}\n     */\n    value: function loadValidators(passedOptions) {\n        if (!passedOptions) {\n            return [];\n        }\n\n        var validators = [];\n\n        Object.keys(validatorsByName).forEach(function(name) {\n            var v = validatorsByName[name];\n\n            // skip unknown\n            var coveredOptions = v.coveredOptions || (v.options && Object.keys(v.options));\n            if (!coveredOptions || !coveredOptions.length) {\n                return;\n            }\n\n            // store used\n            for (var i = 0, l = coveredOptions.length; i < l; i += 1) {\n                if (passedOptions.indexOf(coveredOptions[i]) !== -1) {\n                    v._name = name;\n                    validators.push(v);\n                    return;\n                }\n            }\n        });\n\n        return validators;\n    }\n});\n\nObject.defineProperty(validatorsByName, 'checkOptions', {\n    /**\n     * Validates passed options\n     *\n     * @param {Object} validator\n     * @param {Object} options\n     * @throws {Error} If option is not valid\n     */\n    value: function checkOptions(validator, options) {\n        Object.keys(validator.options).forEach(function(option) {\n            var data = validator.options[option];\n            if (!data.allowedValues) {\n                return;\n            }\n\n            var values = data.allowedValues;\n            if (typeof values === 'function') {\n                values = values();\n            }\n\n            assert(Array.isArray(values), 'Internal error in jsDoc validator ' + validator._name);\n\n            if (values.length > 1) {\n                assert(values.indexOf(options[option]) !== -1,\n                    'Accepted values for option jsDoc.' + option + ' are ' + values.map(JSON.stringify).join(', '));\n\n            } else if (values.length) {\n                assert(values[0] === options[option],\n                    'Only accepted value for jsDoc.' + option + ' is ' + JSON.stringify(values[0]));\n            }\n        });\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-types.js":"var jsdoc = require('../../jsdoc');\n\nmodule.exports = validateTypesInTags;\nmodule.exports.scopes = ['file'];\nmodule.exports.options = {\n    checkTypes: {allowedValues: [true, 'strictNativeCase', 'capitalizedNativeCase']}\n};\n\nvar allowedTags = {\n    // common\n    typedef: true,\n    type: true,\n    param: true,\n    'return': true,\n    returns: true,\n    'enum': true,\n\n    // jsdoc\n    'var': true,\n    prop: true,\n    property: true,\n    arg: true,\n    argument: true,\n\n    // jsduck\n    cfg: true,\n\n    // closure\n    lends: true,\n    extends: true,\n    implements: true,\n    define: true\n};\n\nvar strictNatives = {\n    // lowercased\n    boolean: 'boolean',\n    number: 'number',\n    string: 'string',\n    // titlecased\n    array: 'Array',\n    object: 'Object',\n    regexp: 'RegExp',\n    date: 'Date',\n    'function': 'Function'\n};\n\n/**\n * Validator for types in tags\n *\n * @param {JSCS.JSFile} file\n * @param {JSCS.Errors} errors\n */\nfunction validateTypesInTags(file, errors) {\n    var strictNativeCase = this._options.checkTypes === 'strictNativeCase';\n    var capitalizedNativeCase = this._options.checkTypes === 'capitalizedNativeCase';\n\n    var comments = file.getComments();\n    comments.forEach(function(commentNode) {\n        if (commentNode.type !== 'CommentBlock' || commentNode.value[0] !== '*') {\n            return;\n        }\n\n        // trying to create DocComment object\n        var node = jsdoc.createDocCommentByCommentNode(commentNode);\n        if (!node.valid) {\n            return;\n        }\n\n        node.iterateByType(Object.keys(allowedTags),\n            /**\n             * @param {DocType} tag\n             */\n            function(tag) {\n\n                if (!tag.type) {\n                    // skip untyped params\n                    return;\n                }\n                if (!tag.type.valid) {\n                    // throw an error if not valid\n                    errors.add('Expects valid type instead of ' + tag.type.value, commentNode, tag.type.loc.offset);\n                }\n                if (strictNativeCase || capitalizedNativeCase) {\n                    tag.type.iterate(function(node) {\n                        // it shouldn't be!\n                        if (!node.typeName) {\n                            // skip untyped unknown things\n                            return;\n                        }\n\n                        // is native?\n                        var type = node.typeName;\n                        var lowerType = type.toLowerCase();\n                        if (!strictNatives.hasOwnProperty(lowerType)) {\n                            return;\n                        }\n\n                        var normType = strictNatives[lowerType];\n                        if (strictNativeCase && type !== normType ||\n                            capitalizedNativeCase && type !== (normType[0].toUpperCase() + normType.substr(1))) {\n                            errors.add('Invalid case of type `' + type + '`', commentNode, tag.type.loc.offset);\n                        }\n                    });\n                }\n            });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-param-existence.js":"module.exports = checkParamExistence;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    checkParamExistence: {allowedValues: [true]}\n};\n\n/**\n * validator for check-param-existence\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction checkParamExistence(node, err) {\n    if (!node.jsdoc) {\n        return;\n    }\n\n    var totalParams = 0;\n    var excludable;\n    var documentedParams = {};\n    node.jsdoc.iterateByType(['param', 'arg', 'argument', 'inheritdoc', 'class', 'extends'],\n        function(tag) {\n            totalParams += 1;\n            if (['inheritdoc', 'class', 'extends'].indexOf(tag.id) > -1) {\n                excludable = true;\n            }\n            // set first instance at place where documentation is missing.\n            if (['arg', 'argument', 'param'].indexOf(tag.id) > -1 && tag.name) {\n                documentedParams[tag.name.value] = true;\n            }\n        });\n    if (totalParams !== node.params.length && !excludable) {\n        node.params.forEach(function(param) {\n            if (!documentedParams[param.name]) {\n                err('Function is missing documentation for parameter `' + param.name + '`.', node);\n            }\n        });\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-param-names.js":"module.exports = validateCheckParamNames;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    checkParamNames: {allowedValues: [true]}\n};\n\n/**\n * Validator for check-param-names\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction validateCheckParamNames(node, err) {\n    if (!node.jsdoc || !node.jsdoc.valid) {\n        return;\n    }\n\n    // outOfOrder\n    var paramsByName = {};\n    node.params.forEach(function(param) {\n        paramsByName[param.name] = param;\n    });\n    var paramTagsByName = {};\n    node.jsdoc.iterateByType(['param', 'arg', 'argument'], function(tag) {\n        if (tag.name && tag.name.value) {\n            paramTagsByName[tag.name.value] = tag;\n        }\n    });\n    var outOfOrder = {};\n    var skipped = 0;\n    var lastRootParamTag;\n\n    node.jsdoc.iterateByType(['param', 'arg', 'argument'],\n        /**\n         * Tag checker\n         *\n         * @param {DocType} tag\n         * @param {number} i index\n         */\n        function(tag, i) {\n            // There is no parameter name in destructuring assignments.\n            if (node.params[i - skipped] && node.params[i - skipped].name === undefined) {\n                // So if there is no tag name or the tag name does not contain '.', there is nothing to check.\n                if (!tag.name || tag.name.value.indexOf('.') === -1) {\n                    lastRootParamTag = tag;\n                    return;\n                }\n            }\n\n            // hecking validity\n            if (!tag.name) {\n                return err('Missing param name', tag.loc);\n            }\n\n            var dotPosition = tag.name.value.indexOf('.');\n            if (dotPosition !== -1) {\n                var dottedRootParam = tag.name.value.substr(0, dotPosition);\n                if (dotPosition === 0 || !(dottedRootParam = tag.name.value.substr(0, dotPosition))) {\n                    err('Invalid param name', tag.name.loc);\n                } else if (!lastRootParamTag) {\n                    err('Inconsistent param found', tag.name.loc);\n                } else if (lastRootParamTag.name.value !== dottedRootParam) {\n                    err('Expected `' + lastRootParamTag.name.value + '` but got `' + dottedRootParam + '`',\n                        tag.name.loc);\n                }\n                skipped++;\n                return;\n            }\n\n            lastRootParamTag = tag;\n\n            var param = node.params[i - skipped];\n            if (!param) {\n                // skip if no param\n                return;\n            }\n\n            // checking name\n            var msg;\n            if (tag.name.value !== param.name && !outOfOrder[tag.name.value]) {\n                if (paramsByName[tag.name.value] && paramTagsByName[param.name]) {\n                    outOfOrder[tag.name.value] = outOfOrder[param.name] = true;\n                    msg = 'Parameters ' + tag.name.value + ' and ' + param.name + ' are out of order';\n                } else if (paramsByName[tag.name.value]) {\n                    outOfOrder[tag.name.value] = true;\n                    msg = 'Parameter ' + tag.name.value + ' is out of order';\n                } else {\n                    msg = 'Expected ' + param.name + ' but got ' + tag.name.value;\n                }\n\n                return err(msg, tag.name.loc);\n            }\n        });\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-redundant-params.js":"module.exports = validateCheckParamNames;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    checkRedundantParams: {allowedValues: [true]}\n};\n\n/**\n * Validator for check-param-names\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction validateCheckParamNames(node, err) {\n    if (!node.jsdoc || !node.jsdoc.valid) {\n        return;\n    }\n\n    var skipped = 0;\n\n    node.jsdoc.iterateByType(['param', 'arg', 'argument'],\n        /**\n         * Tag checker\n         *\n         * @param {DocType} tag\n         * @param {number} i index\n         */\n        function(tag, i) {\n            // skip if there is dot in param name (object's inner param)\n            if (tag.name && tag.name.value.indexOf('.') !== -1) {\n                skipped++;\n                return;\n            }\n\n            var _optional = tag.optional || (tag.type && (tag.type.optional || tag.type.variable));\n            if (_optional) {\n                skipped++;\n                return;\n            }\n\n            var param = node.params[i - skipped];\n\n            // checking redundant\n            if (!param) {\n                return err('Found redundant ' +\n                    (tag.name ? 'param \"' + tag.name.value + '\"' : 'unnamed param') +\n                    ' statement', tag.loc);\n            }\n        });\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-param-types.js":"module.exports = validateParamTag;\nmodule.exports.tags = ['param', 'arg', 'argument'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireParamTypes: {allowedValues: [true]}\n};\n\n/**\n * Validator for @param\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction validateParamTag(node, tag, err) {\n    // checking existance\n    if (tag.type) {\n        return;\n    }\n    return err('Missing param type', (tag.name ? tag.name.loc : null) || tag.loc);\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-param-description.js":"module.exports = validateParamTagDescription;\nmodule.exports.tags = ['param', 'arg', 'argument'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireParamDescription: {allowedValues: [true]}\n};\n\n/**\n * Validator for @param\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction validateParamTagDescription(node, tag, err) {\n    // checking existance\n    if (tag.description) {\n        return;\n    }\n\n    var offset = (tag.name && tag.name.value && tag.name.value.length) || 0;\n    var loc = (tag.name ? tag.name.loc : null) || tag.loc;\n\n    return err('Missing param description', loc.shift(offset));\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-hyphen-before-description.js":"module.exports = requireHyphenBeforeDescription;\nmodule.exports.tags = ['param', 'arg', 'argument'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireHyphenBeforeDescription: {allowedValues: [true]}\n};\n\n/**\n * Checking returns types\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction requireHyphenBeforeDescription(node, tag, err) {\n    if (!tag.description) {\n        return;\n    }\n\n    // skip reporting if there is new line in description\n    // todo: check this with newline of name and description when it'll be possible\n    if (tag.value.indexOf('\\n') !== -1 && tag.description.indexOf('\\n') === -1) {\n        return;\n    }\n\n    if (tag.description.substring(0, 2) !== '- ') {\n        err('Missing hyphen before description', tag.loc);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-return-types.js":"module.exports = checkReturnTypes;\nmodule.exports.tags = ['return', 'returns'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    checkReturnTypes: {allowedValues: [true]}\n};\n\n/**\n * Checking returns types\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction checkReturnTypes(node, tag, err) {\n    // try to check returns types\n    if (!tag.type || !tag.type.valid) {\n        return;\n    }\n\n    var returnsArgumentStatements = this._getReturnStatementsForNode(node);\n    returnsArgumentStatements.forEach(function(argument) {\n        if (!tag.type.match(argument)) {\n            err('Wrong returns value', argument);\n        }\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-return-types.js":"module.exports = requireReturnTypes;\nmodule.exports.tags = ['return', 'returns'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireReturnTypes: {allowedValues: [true]}\n};\n\n/**\n * Requiring returns types (?)\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction requireReturnTypes(node, tag, err) {\n    if (!tag.type) {\n        err('Missing type in @returns statement', tag.loc);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-return-description.js":"module.exports = validateReturnTagDescription;\nmodule.exports.tags = ['return', 'returns'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireReturnDescription: {allowedValues: [true]}\n};\n\n/**\n * Validator for @return description.\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction validateReturnTagDescription(node, tag, err) {\n    // Check tag existence. Note: for @returns tag, description is parsed as a name.\n    if (tag.name) {\n        return;\n    }\n\n    return err('Missing return description', tag.loc);\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-redundant-returns.js":"module.exports = checkReturnTypes;\nmodule.exports.tags = ['return', 'returns'];\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    checkRedundantReturns: {allowedValues: [true]}\n};\n\n/**\n * Checking returns types\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {DocTag} tag\n * @param {Function} err\n */\nfunction checkReturnTypes(node, tag, err) {\n    // checking consistency\n    if (!tag.type) {\n        return;\n    }\n\n    // skip abstract methods\n    if (node.jsdoc.abstract) {\n        return;\n    }\n\n    // checking redundant: invalid or not return statements in code\n    var redundant = !Boolean(this._getReturnStatementsForNode(node).length);\n\n    if (redundant) {\n        err('Redundant return statement', tag.loc);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-annotations.js":"var assert = require('assert');\n\nvar availablePresets = require('../../tags');\nvar jsdoc = require('../../jsdoc');\n\nmodule.exports = validateAnnotations;\nmodule.exports.scopes = ['file'];\nmodule.exports.options = {\n    checkAnnotations: true\n};\n\n/**\n * @param {Object} options\n */\nvalidateAnnotations.configure = function(options) {\n    var o = options.checkAnnotations;\n\n    assert(o === true || typeof o === 'string' || typeof o === 'object',\n        'jsDoc.checkAnnotation rule was not configured properly');\n\n    if (typeof o === 'string') {\n        o = {preset: o};\n    } else if (typeof o === 'object') {\n        var oKeys = Object.keys(o);\n        oKeys.forEach(function(key) {\n            if (key === 'preset') {\n                assert(typeof o.preset === 'string', 'jsDoc.checkAnnotation.preset should be preset name');\n            } else if (key === 'extra') {\n                assert(typeof o[key] === 'object', 'jsDoc.checkAnnotation.preset should be `tag: fulfill` map');\n            } else {\n                throw new Error('jsDoc.checkAnnotation.' + key + ' is unsupported field');\n            }\n        });\n    }\n\n    var tags = this._tags = Object.create ? Object.create(null) : {};\n\n    if (o === true) {\n        Object.keys(availablePresets).forEach(function(preset) {\n            var presetTags = availablePresets[preset];\n            Object.keys(presetTags).forEach(function(tag) {\n                tags[tag] = tags[tag] || presetTags[tag];\n            });\n        });\n\n    } else if (typeof o === 'object') {\n        if (o.preset) {\n            assert(availablePresets[o.preset], 'Unknown tag preset ' + o.preset);\n            Object.keys(availablePresets[o.preset]).forEach(function(tag) {\n                tags[tag] = tags[tag] || availablePresets[o.preset][tag];\n            });\n        }\n        if (o.extra) {\n            Object.keys(o.extra).forEach(function(tag) {\n                if (o.extra[tag] === null) {\n                    delete tags[tag];\n                } else {\n                    tags[tag] = o.extra[tag];\n                }\n            });\n        }\n    }\n};\n\n/**\n * Validator for annotations\n *\n * @param {JSCS.JSFile} file\n * @param {JSCS.Errors} errors\n */\nfunction validateAnnotations(file, errors) {\n    var comments = file.getComments();\n    var tags = this._tags;\n    comments.forEach(function(commentNode) {\n        if (commentNode.type !== 'CommentBlock' || commentNode.value[0] !== '*') {\n            return;\n        }\n\n        // trying to create DocComment object\n        var node = jsdoc.createDocCommentByCommentNode(commentNode);\n        if (!node.valid) {\n            return;\n        }\n\n        node.iterate(function(tag) {\n            if (!(tag.id in tags)) {\n                errors.add('Unavailable tag ' + tag.id, commentNode, tag.loc.offset);\n                return;\n            }\n\n            // checking tag fullfill\n            var isFilled = tag.name || tag.type || tag.description;\n            switch (tags[tag.id]) {\n                case false:\n                    if (isFilled) {\n                        errors.add('Unexpected data in tag ' + tag.id, commentNode, tag.loc.offset);\n                    }\n                    break;\n\n                case true:\n                    // any data\n                    break;\n\n                case 'some':\n                    if (!isFilled) {\n                        errors.add('Incomplete data in tag ' + tag.id, commentNode, tag.loc.offset);\n                    }\n                    break;\n\n                default:\n                    // unknown\n                    break;\n            }\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/tags/index.js":"module.exports = {\n    jsdoc3: require('./jsdoc3'),\n    jsduck5: require('./jsduck5'),\n    closurecompiler: require('./closurecompiler')\n};\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-newline-after-description.js":"module.exports = requireNewlineAfterDescription;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    requireNewlineAfterDescription: {allowedValues: [true]}\n};\n\nvar RE_NEWLINE_AT_THE_END = /\\n$/;\n\n/**\n * Requires newline after description in jsdoc comment\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction requireNewlineAfterDescription(node, err) {\n    var doc = node.jsdoc;\n    if (!doc || !doc.tags.length || !doc.description || !doc.description.length) {\n        return;\n    }\n\n    if (!RE_NEWLINE_AT_THE_END.test(doc.description)) {\n        err('Newline required after description', doc.description.length + 1);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/disallow-newline-after-description.js":"module.exports = disallowNewlineAfterDescription;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    disallowNewlineAfterDescription: {allowedValues: [true]}\n};\n\nvar RE_NEWLINE_AT_THE_END = /\\n$/;\n\n/**\n * Disallows newline after description in jsdoc comment\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction disallowNewlineAfterDescription(node, err) {\n    var doc = node.jsdoc;\n    if (!doc || !doc.tags.length || !doc.description || !doc.description.length) {\n        return;\n    }\n\n    if (!RE_NEWLINE_AT_THE_END.test(doc.description)) {\n        return;\n    }\n\n    err('Newline required after description', doc.tags[0].loc.offset - 4);\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/require-description-complete-sentence.js":"module.exports = requireDescriptionCompleteSentence;\nmodule.exports.scopes = ['function', 'variable'];\nmodule.exports.options = {\n    requireDescriptionCompleteSentence: {allowedValues: [true]}\n};\n\n/**\n * Checks that every sentence starts with an upper case letter.\n *\n * This matches when a new line or start of a blank line\n * does not start with an upper case letter.\n * It also matches a period not fllowed by an upper case letter.\n */\nvar RE_NEW_LINE_START_WITH_UPPER_CASE = /((\\n\\s*\\n)|(?:\\w{2,})\\.)\\s*[a-z]/g;\n\nvar START_DESCRIPTION = /^\\s*[a-z]/g;\n\nvar RE_END_DESCRIPTION = /\\n/g;\n\n/**\n * Checks next lines with uppercase letters have periods.\n *\n * This checks for the existance of a new line that starts with an\n * upper case letter where the previous line does not have a period\n * Note that numbers count as word characters.\n */\nvar RE_NEW_LINE_UPPERCASE = /\\w(?!\\.)(\\W)*\\n\\W*[A-Z]/g;\n\n/**\n * Checks that a sentence followed by a blank line has a period\n *\n * If the above line did not have a period this would match.\n * this also checks that the last sentence in the description ends with a period.\n *\n * This also matches white-space followed by a period.\n */\nvar RE_END_WITH_PERIOD = /(\\s\\.|[^\\s\\.])(?!\\.)(\\n|$)\\s*(\\n|$)/g;\n\n/**\n * Requires description to be a complete sentence in a jsdoc comment.\n *\n * a complete sentence is defined by starting with an upper letter\n * and ending with a period.\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction requireDescriptionCompleteSentence(node, err) {\n    var doc = node.jsdoc;\n    if (!doc || !doc.description || !doc.description.length) {\n        return;\n    }\n\n    var sanitized = doc.description\n        .replace(/(`)([^`]+)\\1/, quotedSanitizer)\n        .replace(/(')([^']+)\\1/, quotedSanitizer)\n        .replace(/(\")([^\"]+)\\1/, quotedSanitizer)\n        // sanitize HTML tags which close\n        .replace(/<([^ >]+)[^>]*>[\\s\\S]*?.*?<\\/\\1>|<[^\\/]+\\/>/g, htmlSanitizer)\n        // sanitize self-closing HTML tags eg <br>\n        .replace(/<([^ >]+)[^>]*>/g, htmlSanitizer)\n        .replace(/\\{([^}]+)\\}/, function(_, m) {\n            return '{' + (new Array(m.length + 1)).join('*') + '}';\n        })\n        .replace(/\\r/g, ' ')\n        .replace(/:(\\n+)/, function(_, n) {\n            return ':' + n.replace(/\\n/g, ' ');\n        });\n    var lines = sanitized.split(RE_END_DESCRIPTION);\n\n    var errors = [];\n\n    if (START_DESCRIPTION.test(sanitized)) {\n        var matches = returnAllMatches(sanitized, START_DESCRIPTION);\n        matches.map(function(match) {\n            match.message = 'Description must start with an upper case letter';\n            match.index = match.start;\n        });\n        errors = errors.concat(matches);\n    }\n\n    if (RE_NEW_LINE_START_WITH_UPPER_CASE.test(sanitized)) {\n        var matches1 = returnAllMatches(sanitized, RE_NEW_LINE_START_WITH_UPPER_CASE);\n        matches1.map(function(match) {\n            match.message = 'Sentence must start with an upper case letter';\n            match.index = match.end - 1;\n        });\n        errors = errors.concat(matches1);\n    }\n\n    if (RE_END_WITH_PERIOD.test(sanitized)) {\n        var matches2 = returnAllMatches(sanitized, RE_END_WITH_PERIOD);\n        matches2.map(function(match) {\n            match.message = 'Sentence must end with a period';\n            match.index = match.start;\n        });\n        errors = errors.concat(matches2);\n    }\n\n    if (RE_NEW_LINE_UPPERCASE.test(sanitized)) {\n        var matches3 = returnAllMatches(sanitized, RE_NEW_LINE_UPPERCASE);\n        matches3.map(function(match) {\n            match.message = 'You started a new line with an upper case letter but ' +\n                'previous line does not end with a period';\n            match.index = match.end - 1;\n        });\n        errors = errors.concat(matches3);\n    }\n\n    computeErrors(err, errors, lines);\n}\n\n/**\n * Given a list of matches it records offenses.\n *\n * This will only go through the description once for all offenses.\n *\n * @param {Function} err\n * @param {Array} matches An array of matching offenses.\n * @param {number} matches.start The starting index of the match.\n * @param {string} matches.message The message of the offence.\n * @param {Array} lines The lines in this description.\n */\nfunction computeErrors(err, matches, lines) {\n    var indexInString = 0;\n    var currentMatch = 0;\n    var offset = 0;\n    for (var currentLine = 0; currentLine < lines.length &&\n            currentMatch < matches.length; currentLine++) {\n\n        var nextIndexInString = indexInString + lines[currentLine].length;\n        while (currentMatch < matches.length && matches[currentMatch].index >= indexInString &&\n                matches[currentMatch].index <= nextIndexInString) {\n\n            // currentLine is to account for additional extra characters being added.\n            err(matches[currentMatch].message, 0);\n\n            currentMatch++;\n        }\n        indexInString = nextIndexInString;\n        offset += lines[currentLine].length + 1;\n    }\n}\n\n/**\n * Returns all matches of regex in input as an array.\n *\n * @return {Array} Each element in the array has two values: start and end.\n */\nfunction returnAllMatches(input, regex) {\n    var match;\n    var indexes = [];\n\n    // resets the last index so that exec does not return null.\n    regex.lastIndex = 0;\n    do {\n        match = regex.exec(input);\n        if (match === null) {\n            break;\n        }\n        indexes.push({\n            start: match.index,\n            end: match.index + match[0].length\n        });\n    } while (match !== null);\n    return indexes;\n}\n\n/**\n * Quoted part sanitizer used for replace matcher.\n *\n * @private\n * @param {string} _ - Full matched string\n * @param {string} q - Quote character\n * @param {string} m - Matched string\n * @returns {string} - Sanitized string\n */\nfunction quotedSanitizer(_, q, m) {\n    var endsWithDot = /\\.\\s*$/.test(m);\n    return q + (new Array(m.length + (endsWithDot ? 0 : 1))).join('*') + q + (endsWithDot ? '.' : '');\n}\n\n/**\n * HTML part sanitizer.\n * To prevent RE_NEW_LINE_START_WITH_UPPER_CASE\n * return string will padded by 'x.'\n *\n * @private\n * @param {string} _ - Full matched string\n * @returns {string} - Sanitized string\n */\nfunction htmlSanitizer(_) {\n    return _.split('').map(function(token, iterator) {\n        if (iterator === _.length - 1) {\n            return 'x.';\n        }\n        return token === '\\n' ? '\\n' : '*';\n    }).join('');\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/check-redundant-access.js":"module.exports = checkRedundantAccess;\nmodule.exports.scopes = ['function'];\n\nmodule.exports.options = {\n    checkRedundantAccess: {allowedValues: [true, 'enforceLeadingUnderscore', 'enforceTrailingUnderscore']}\n};\n\n/**\n * Validator for @access\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction checkRedundantAccess(node, err) {\n    var enforceLeadingUnderscore = this._options.checkRedundantAccess === 'enforceLeadingUnderscore';\n    var enforceTrailingUnderscore = this._options.checkRedundantAccess === 'enforceTrailingUnderscore';\n    if (!node.jsdoc || !node.jsdoc.valid) {\n        return;\n    }\n\n    var access;\n    node.jsdoc.iterateByType(['private', 'protected', 'public', 'access'], function(tag) {\n        if (access) {\n            err('Multiple access definition', tag.loc);\n            return;\n        }\n\n        if (tag.id === 'access' && !tag.name) {\n            err('Invalid access definition', tag.loc);\n        }\n\n        access = tag.id === 'access' ? tag.name.value : tag.id;\n    });\n\n    // skip unknown and don't check if no forcing\n    if (typeof access === 'undefined' || access === 'public' ||\n        !(enforceLeadingUnderscore || enforceTrailingUnderscore)) {\n        return;\n    }\n\n    // fetch name from variable, property or function\n    var name;\n    var nodeToReport;\n    switch (node.parentElement.type) {\n        case 'VariableDeclarator':\n            name = node.parentElement.id.name;\n            nodeToReport = node.parentElement.id;\n            break;\n        case 'ObjectProperty':\n            name = node.parentElement.key.name;\n            nodeToReport = node.parentElement.key;\n            break;\n        default: // try to use func name itself (if not anonymous)\n            name = (node.id || {}).name;\n            nodeToReport = node.id || node;\n            break;\n    }\n\n    // skip anonymous and names without underscores at begin\n    if (name && name[enforceLeadingUnderscore ? 0 : (name.length - 1)] !== '_') {\n        err('Missing ' + (enforceLeadingUnderscore ? 'leading' : 'trailing') +\n            ' underscore for ' + name, nodeToReport);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/enforce-existence.js":"var assert = require('assert');\nvar esprimaHelpers = require('../../esprima-helpers');\n\nmodule.exports = enforceExistence;\nmodule.exports.scopes = ['function'];\nmodule.exports.options = {\n    enforceExistence: true\n};\n\n/**\n * @param {Object} options\n */\nenforceExistence.configure = function(options) {\n\n    // set default policy\n    var policy = this._enforceExistencePolicy = {\n        all: true,\n        anonymous: false,\n        arrow: true,\n        exports: true,\n        expressions: true,\n        'paramless-procedures': true,\n    };\n\n    // check options are valid\n    var o = options.enforceExistence;\n    assert(\n        o === true || o === false || typeof o === 'string' || (typeof o === 'object' && Array.isArray(o.allExcept)),\n        'jsDoc.enforceExistence rule was not configured properly'\n    );\n\n    var optionsToPolicyMap = Object.keys(policy);\n    /**\n     * @param {string} option\n     */\n    function updatePolicyRules(option) {\n        if (o.allExcept.indexOf(option) > -1) {\n            policy[option] = !policy[option];\n        }\n    }\n\n    // parse options for policies\n    if (o === false) {\n        policy.all = false;\n    } else if (typeof o === 'string' && o === 'exceptExports') { // backward compatible string option\n        policy.exports = false;\n    } else if (typeof o === 'object' && Array.isArray(o.allExcept)) {\n        optionsToPolicyMap.forEach(updatePolicyRules);\n    }\n\n};\n\n/**\n * Validator for jsdoc data existence\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction enforceExistence(node, err) {\n    var policy = this._enforceExistencePolicy;\n\n    // enforce 'break-out' policies\n    var parentNode = node.parentElement || {};\n\n    if (policy.all === false) {\n        // don't check anything\n        return;\n    }\n\n    if (policy.anonymous === false && node.type !== 'ArrowFunctionExpression' ||\n        policy.arrow === false && node.type === 'ArrowFunctionExpression') {\n        if (!node.id && ['AssignmentExpression', 'VariableDeclarator', 'ObjectProperty',\n            'ExportDefaultDeclaration'].indexOf(parentNode.type) === -1) {\n            // don't check anonymous functions\n            return;\n        }\n    }\n    if (policy.exports === false) {\n        if (parentNode.type === 'ExportDefaultDeclaration' || parentNode.type === 'ExportNamedDeclaration') {\n            // don't check es6 export\n            return;\n        } else if (parentNode.type === 'AssignmentExpression') {\n            var left = parentNode.left;\n            if ((left.object && left.object.name) === 'module' &&\n                (left.property && left.property.name) === 'exports') {\n                // don't check commonjs exports format\n                return;\n            }\n        }\n    }\n    if (policy.expressions === false) {\n        if (['AssignmentExpression', 'VariableDeclarator', 'ObjectProperty'].indexOf(parentNode.type) > -1) {\n            // don't check expression functions\n            return;\n        }\n    }\n    if (policy['paramless-procedures'] === false) {\n        var hasReturnsWhichRequireJsdoc = false;\n        this._iterate(function(n) {\n            if (hasReturnsWhichRequireJsdoc) {\n                return;\n            }\n            var isReturnWithValue = n && n.type === 'ReturnStatement' && n.argument;\n            var isInCurrentScope = node === esprimaHelpers.closestScopeNode(n);\n            hasReturnsWhichRequireJsdoc = isReturnWithValue && isInCurrentScope;\n        }, node);\n        if (!node.params.length && !hasReturnsWhichRequireJsdoc) {\n            // don't check functions without params\n            return;\n        }\n    }\n\n    // now clear to check for documentation\n    if (node.jsdoc) {\n        if (!node.jsdoc.valid) {\n            err('Invalid jsdoc-block definition', node.jsdoc.loc.offset);\n        }\n        return;\n    }\n\n    // report absence\n    err('Expect valid jsdoc-block definition', node);\n\n}\n","/home/travis/build/npmtest/node-npmtest-jscs-jsdoc/node_modules/jscs-jsdoc/lib/rules/validate-jsdoc/leading-underscore-access.js":"module.exports = validateLeadingUnderscoresAccess;\nmodule.exports.scopes = ['function'];\n\nmodule.exports.options = {\n    leadingUnderscoreAccess: {\n        allowedValues: [true, 'private', 'protected']\n    }\n};\n\nvar nativeUnderscoredProperties = [\n    // standard\n    '__proto__',\n    // underscore\n    '_',\n    // node.js\n    '__filename',\n    '__dirname',\n    'super_', // util.inherits\n    // moz\n    '__count__',\n    '__parent__',\n    '__defineGetter__',\n    '__defineSetter__',\n    '__lookupGetter__',\n    '__lookupSetter__',\n    '__noSuchMethod__',\n    // dfilatov/inherit\n    '__constructor',\n    '__self',\n    '__base',\n    '__parent',\n];\n\n/**\n * Validator for jsdoc data existance\n *\n * @param {(FunctionDeclaration|FunctionExpression)} node\n * @param {Function} err\n */\nfunction validateLeadingUnderscoresAccess(node, err) {\n    var option = this._options.leadingUnderscoreAccess;\n    if (!node.jsdoc || !node.jsdoc.valid) {\n        return;\n    }\n\n    // fetch name from variable, property or function\n    var name;\n    var nodeToReport;\n\n    switch (node.parentElement.type) {\n        case 'VariableDeclarator':\n            name = node.parentElement.id.name;\n            nodeToReport = node.parentElement.id;\n            break;\n        case 'ObjectProperty':\n            name = node.parentElement.key.name;\n            nodeToReport = node.parentElement.key;\n            break;\n        default: // try to use func name itself (if not anonymous)\n            name = (node.id || {}).name;\n            nodeToReport = node.id || node;\n            break;\n    }\n\n    if (nativeUnderscoredProperties.indexOf(name) !== -1) {\n        return;\n    }\n\n    // skip anonymous and names without underscores at begin\n    if (!name || name[0] !== '_') {\n        return;\n    }\n\n    var access;\n    var accessTag;\n    var override = false;\n    node.jsdoc.iterate(function(tag) {\n        if (!access && ['private', 'protected', 'public', 'access'].indexOf(tag.id) !== -1) {\n            access = (tag.id === 'access' ? tag.name.value : tag.id);\n            accessTag = tag;\n        } else if (tag.id === 'override') {\n            override = true;\n        }\n    });\n\n    if (!access || !accessTag) {\n        if (!override) {\n            err('Missing access tag for ' + (name || 'anonymous function'), nodeToReport);\n        }\n    } else if ([true, access].indexOf(option) === -1) {\n        err('Method access doesn\\'t match', accessTag.loc);\n    }\n}\n"}